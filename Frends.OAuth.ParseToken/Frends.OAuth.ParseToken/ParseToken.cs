using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.IdentityModel.Tokens.Jwt;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Frends.OAuth.ParseToken.Definitions;
using Microsoft.IdentityModel.Protocols;
using Microsoft.IdentityModel.Protocols.OpenIdConnect;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using ThirdParty.BouncyCastle.OpenSsl;

namespace Frends.OAuth.ParseToken;

/// <summary>
/// OAuth operation task.
/// </summary>
public class OAuth
{
    /// <summary>
    /// Parses the provided OAuth JWT token or Authorization header.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.OAuth.ParseToken)
    /// </summary>
    /// <param name="input">Input parameters</param>
    /// <param name="options">Option parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { ClaimsPrincipal ClaimsPrincipal, SecurityToken Token }</returns>
    public static async Task<ParseResult> ParseToken([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        var config = await GetConfiguration(input, cancellationToken).ConfigureAwait(false);
        var decryptionKeys = new List<SecurityKey>();

        // Create key(s) for decryption if needed.
        if (options.DecryptToken)
        {
            var decReader = new PemReader(new StringReader(options.DecryptionKey));
            var encRsaParameters = decReader.ReadPrivatekey();
            decryptionKeys.Add(new RsaSecurityKey(encRsaParameters));
        }

        var validationParameters = new TokenValidationParameters
        {
            ValidIssuer = input.Issuer,
            ValidAudiences = new[] { input.Audience },
            IssuerSigningKeys = config.SigningKeys,
            ValidateLifetime = !options.SkipLifetimeValidation,
            ValidateAudience = !options.SkipAudienceValidation,
            ValidateIssuer = !options.SkipIssuerValidation,
            TokenDecryptionKeys = options.DecryptToken ? decryptionKeys : null
        };
        var handler = new JwtSecurityTokenHandler();
        var user = handler.ValidateToken(input.GetToken(), validationParameters, out var validatedToken);

        return new ParseResult
        {
            ClaimsPrincipal = user,
            Token = validatedToken,
        };
    }

    private static readonly ConcurrentDictionary<string, IConfigurationManager<OpenIdConnectConfiguration>> ConfigurationManagerCache = new();
    private static readonly SemaphoreSlim InitLock = new(1, 1);

    private static async Task<OpenIdConnectConfiguration> GetConfiguration(Input input, CancellationToken cancellationToken)
    {

        if (input.ConfigurationSource == ConfigurationSource.Static)
        {
            var configuration = new OpenIdConnectConfiguration()
            {
                JsonWebKeySet = JsonConvert.DeserializeObject<JsonWebKeySet>(input.StaticJwksConfiguration)
            };
            foreach (var key in configuration.JsonWebKeySet.GetSigningKeys())
            {
                configuration.SigningKeys.Add(key);
            }

            return configuration;
        }

        if (ConfigurationManagerCache.TryGetValue(input.Issuer, out var configurationManager))
            return await configurationManager.GetConfigurationAsync(cancellationToken).ConfigureAwait(false);
        await InitLock.WaitAsync(TimeSpan.FromSeconds(10), cancellationToken).ConfigureAwait(false);
        try
        {
            configurationManager = ConfigurationManagerCache.GetOrAdd(input.Issuer, issuer =>
                new ConfigurationManager<OpenIdConnectConfiguration>(
                    input.WellKnownConfigurationUrl,
                    new OpenIdConnectConfigurationRetriever()
                ));
        }
        finally
        {
            InitLock.Release();
        }

        return await configurationManager.GetConfigurationAsync(cancellationToken).ConfigureAwait(false);
    }
}